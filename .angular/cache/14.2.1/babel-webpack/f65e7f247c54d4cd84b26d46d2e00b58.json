{"ast":null,"code":"import { getBsVer } from 'ngx-bootstrap/utils';\nimport * as i0 from '@angular/core';\nimport { PLATFORM_ID, Injectable, Inject, ElementRef } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, merge, fromEvent, of, animationFrameScheduler } from 'rxjs';\nvar MapPlacementInToRL;\n\n(function (MapPlacementInToRL) {\n  MapPlacementInToRL[\"top\"] = \"top\";\n  MapPlacementInToRL[\"bottom\"] = \"bottom\";\n  MapPlacementInToRL[\"left\"] = \"left\";\n  MapPlacementInToRL[\"right\"] = \"right\";\n  MapPlacementInToRL[\"auto\"] = \"auto\";\n  MapPlacementInToRL[\"end\"] = \"right\";\n  MapPlacementInToRL[\"start\"] = \"left\";\n  MapPlacementInToRL[\"top left\"] = \"top left\";\n  MapPlacementInToRL[\"top right\"] = \"top right\";\n  MapPlacementInToRL[\"right top\"] = \"right top\";\n  MapPlacementInToRL[\"right bottom\"] = \"right bottom\";\n  MapPlacementInToRL[\"bottom right\"] = \"bottom right\";\n  MapPlacementInToRL[\"bottom left\"] = \"bottom left\";\n  MapPlacementInToRL[\"left bottom\"] = \"left bottom\";\n  MapPlacementInToRL[\"left top\"] = \"left top\";\n  MapPlacementInToRL[\"top start\"] = \"top left\";\n  MapPlacementInToRL[\"top end\"] = \"top right\";\n  MapPlacementInToRL[\"end top\"] = \"right top\";\n  MapPlacementInToRL[\"end bottom\"] = \"right bottom\";\n  MapPlacementInToRL[\"bottom end\"] = \"bottom right\";\n  MapPlacementInToRL[\"bottom start\"] = \"bottom left\";\n  MapPlacementInToRL[\"start bottom\"] = \"start bottom\";\n  MapPlacementInToRL[\"start top\"] = \"left top\";\n})(MapPlacementInToRL || (MapPlacementInToRL = {}));\n\nvar PlacementForBs5;\n\n(function (PlacementForBs5) {\n  PlacementForBs5[\"top\"] = \"top\";\n  PlacementForBs5[\"bottom\"] = \"bottom\";\n  PlacementForBs5[\"left\"] = \"start\";\n  PlacementForBs5[\"right\"] = \"end\";\n  PlacementForBs5[\"auto\"] = \"auto\";\n  PlacementForBs5[\"end\"] = \"end\";\n  PlacementForBs5[\"start\"] = \"start\";\n  PlacementForBs5[\"top left\"] = \"top start\";\n  PlacementForBs5[\"top right\"] = \"top end\";\n  PlacementForBs5[\"right top\"] = \"end top\";\n  PlacementForBs5[\"right bottom\"] = \"end bottom\";\n  PlacementForBs5[\"bottom right\"] = \"bottom end\";\n  PlacementForBs5[\"bottom left\"] = \"bottom start\";\n  PlacementForBs5[\"left bottom\"] = \"start bottom\";\n  PlacementForBs5[\"left top\"] = \"start top\";\n  PlacementForBs5[\"top start\"] = \"top start\";\n  PlacementForBs5[\"top end\"] = \"top end\";\n  PlacementForBs5[\"end top\"] = \"end top\";\n  PlacementForBs5[\"end bottom\"] = \"end bottom\";\n  PlacementForBs5[\"bottom end\"] = \"bottom end\";\n  PlacementForBs5[\"bottom start\"] = \"bottom start\";\n  PlacementForBs5[\"start bottom\"] = \"start bottom\";\n  PlacementForBs5[\"start top\"] = \"start top\";\n})(PlacementForBs5 || (PlacementForBs5 = {}));\n\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  } // NOTE: 1 DOM access here\n\n\n  const window = element.ownerDocument.defaultView;\n  const css = window?.getComputedStyle(element, null); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n\n  return property ? css && css[property] : css;\n}\n/**\n * Returns the offset parent of the given element\n */\n\n\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  const noOffsetParent = null; // NOTE: 1 DOM access here\n\n  let offsetParent = element?.offsetParent; // Skip hidden elements which don't have an offsetParent\n\n  let sibling = void 0;\n\n  while (offsetParent === noOffsetParent && element.nextElementSibling && sibling !== element.nextElementSibling) {\n    // todo: valorkin fix\n    sibling = element.nextElementSibling;\n    offsetParent = sibling.offsetParent;\n  }\n\n  const nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return sibling ? sibling.ownerDocument.documentElement : document.documentElement;\n  } // .offsetParent will return the closest TH, TD or TABLE in case\n\n\n  if (offsetParent && ['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n} // todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction isOffsetContainer(element) {\n  const {\n    nodeName\n  } = element;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n */\n\n\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n/**\n * Finds the offset parent common to the two provided nodes\n */\n\n\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  } // Here we make sure to give as \"start\" the element that comes first in the DOM\n\n\n  const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  const start = order ? element1 : element2;\n  const end = order ? element2 : element1; // Get common ancestor container\n\n  const range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0); // todo: valorkin fix\n\n  const commonAncestorContainer = range.commonAncestorContainer; // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  } // one of the nodes is inside shadowDOM, find which one\n\n\n  const element1root = getRoot(element1);\n\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n/**\n * Finds the first parent of an element that has a transformed property defined\n */\n\n\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement) {\n    return document.documentElement;\n  }\n\n  let el = element.parentElement;\n\n  while (el?.parentElement && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n\n  return el || document.documentElement;\n}\n/**\n * Helper to detect borders of a given element\n */\n\n\nfunction getBordersSize(styles, axis) {\n  const sideA = axis === 'x' ? 'Left' : 'Top';\n  const sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n  return parseFloat(styles[`border${sideA}Width`]) + parseFloat(styles[`border${sideB}Width`]);\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n  const _body = body;\n  const _html = html;\n  const _computedStyle = computedStyle;\n  return Math.max(_body[`offset${axis}`], _body[`scroll${axis}`], _html[`client${axis}`], _html[`offset${axis}`], _html[`scroll${axis}`], 0);\n}\n\nfunction getWindowSizes(document) {\n  const body = document.body;\n  const html = document.documentElement;\n  const computedStyle = void 0;\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n\nfunction getClientRect(offsets) {\n  return { ...offsets,\n    right: (offsets.left || 0) + offsets.width,\n    bottom: (offsets.top || 0) + offsets.height\n  };\n}\n/**\n * Tells if a given input is a number\n */\n\n\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(Number(n));\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction isNumber(value) {\n  return typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]';\n}\n/**\n * Get bounding client rect of given element\n */\n\n\nfunction getBoundingClientRect(element) {\n  const rect = element.getBoundingClientRect(); // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  // try {\n  //   if (isIE(10)) {\n  //     const scrollTop = getScroll(element, 'top');\n  //     const scrollLeft = getScroll(element, 'left');\n  //     if (rect && isNumber(rect.top) && isNumber(rect.left) && isNumber(rect.bottom) && isNumber(rect.right)) {\n  //       rect.top += scrollTop;\n  //       rect.left += scrollLeft;\n  //       rect.bottom += scrollTop;\n  //       rect.right += scrollLeft;\n  //     }\n  //   }\n  // } catch (e) {\n  //   return rect;\n  // }\n\n  if (!(rect && isNumber(rect.top) && isNumber(rect.left) && isNumber(rect.bottom) && isNumber(rect.right))) {\n    return rect;\n  }\n\n  const result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  }; // subtract scrollbar size from sizes\n\n  const sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : undefined;\n  const width = sizes?.width || element.clientWidth || isNumber(rect.right) && isNumber(result.left) && rect.right - result.left || 0;\n  const height = sizes?.height || element.clientHeight || isNumber(rect.bottom) && isNumber(result.top) && rect.bottom - result.top || 0;\n  let horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight - height; // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n\n  if (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n/**\n * Returns the parentNode or the host of the element\n */\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n\n  return element.parentNode || element.host;\n}\n/**\n * Returns the scrolling parent of the given element\n */\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n\n    case '#document':\n      return element.body;\n\n    default:\n  } // Firefox want us to check `-x` and `-y` variations as well\n\n\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getStyleComputedProperty(element);\n\n  if (/(auto|scroll|overlay)/.test(String(overflow) + String(overflowY) + String(overflowX))) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent, fixedPosition = false) {\n  const isHTML = parent.nodeName === 'HTML';\n  const childrenRect = getBoundingClientRect(children);\n  const parentRect = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n  const styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  const borderLeftWidth = parseFloat(styles.borderLeftWidth); // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top ?? 0, 0);\n    parentRect.left = Math.max(parentRect.left ?? 0, 0);\n  }\n\n  const offsets = getClientRect({\n    top: (childrenRect.top ?? 0) - (parentRect.top ?? 0) - borderTopWidth,\n    left: (childrenRect.left ?? 0) - (parentRect.left ?? 0) - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0; // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n\n  if (isHTML) {\n    const marginTop = parseFloat(styles.marginTop);\n    const marginLeft = parseFloat(styles.marginLeft);\n\n    if (isNumber(offsets.top)) {\n      offsets.top -= borderTopWidth - marginTop;\n    }\n\n    if (isNumber(offsets.bottom)) {\n      offsets.bottom -= borderTopWidth - marginTop;\n    }\n\n    if (isNumber(offsets.left)) {\n      offsets.left -= borderLeftWidth - marginLeft;\n    }\n\n    if (isNumber(offsets.right)) {\n      offsets.right -= borderLeftWidth - marginLeft;\n    } // Attach marginTop and marginLeft because in some circumstances we may need them\n\n\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  return offsets;\n}\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n */\n\n\nfunction getScroll(element, side = 'top') {\n  const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  const nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    const html = element.ownerDocument.documentElement;\n    const scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element, excludeScroll = false) {\n  const html = element.ownerDocument.documentElement;\n  const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height = Math.max(html.clientHeight, window.innerHeight || 0);\n  const scrollTop = !excludeScroll ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n  const offset = {\n    top: scrollTop - Number(relativeOffset?.top) + Number(relativeOffset?.marginTop),\n    left: scrollLeft - Number(relativeOffset?.left) + Number(relativeOffset?.marginLeft),\n    width,\n    height\n  };\n  return getClientRect(offset);\n}\n/**\n * Check if the given element is fixed or is inside a fixed parent\n */\n\n\nfunction isFixed(element) {\n  const nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n\n  return isFixed(getParentNode(element));\n}\n\nfunction getBoundaries(target, host, padding = 0, boundariesElement, fixedPosition = false) {\n  // NOTE: 1 DOM access here\n  let boundaries = {\n    top: 0,\n    left: 0\n  };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host); // Handle viewport case\n\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    let boundariesNode;\n\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(host));\n\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = target.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = target.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition); // In case of HTML, we need a different computation\n\n    if (offsets && boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      const {\n        height,\n        width\n      } = getWindowSizes(target.ownerDocument);\n\n      if (isNumber(boundaries.top) && isNumber(offsets.top) && isNumber(offsets.marginTop)) {\n        boundaries.top += offsets.top - offsets.marginTop;\n      }\n\n      if (isNumber(boundaries.top)) {\n        boundaries.bottom = Number(height) + Number(offsets.top);\n      }\n\n      if (isNumber(boundaries.left) && isNumber(offsets.left) && isNumber(offsets.marginLeft)) {\n        boundaries.left += offsets.left - offsets.marginLeft;\n      }\n\n      if (isNumber(boundaries.top)) {\n        boundaries.right = Number(width) + Number(offsets.left);\n      }\n    } else if (offsets) {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  } // Add paddings\n\n\n  if (isNumber(boundaries.left)) {\n    boundaries.left += padding;\n  }\n\n  if (isNumber(boundaries.top)) {\n    boundaries.top += padding;\n  }\n\n  if (isNumber(boundaries.right)) {\n    boundaries.right -= padding;\n  }\n\n  if (isNumber(boundaries.bottom)) {\n    boundaries.bottom -= padding;\n  }\n\n  return boundaries;\n}\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n */\n\n\nfunction getArea({\n  width,\n  height\n}) {\n  return width * height;\n}\n\nfunction computeAutoPlacement(placement, refRect, target, host, allowedPositions = ['top', 'bottom', 'right', 'left'], boundariesElement = 'viewport', padding = 0) {\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  const boundaries = getBoundaries(target, host, padding, boundariesElement);\n  const rects = {\n    top: {\n      width: boundaries?.width ?? 0,\n      height: (refRect?.top ?? 0) - (boundaries?.top ?? 0)\n    },\n    right: {\n      width: (boundaries?.right ?? 0) - (refRect?.right ?? 0),\n      height: boundaries?.height ?? 0\n    },\n    bottom: {\n      width: boundaries?.width ?? 0,\n      height: (boundaries?.bottom ?? 0) - (refRect?.bottom ?? 0)\n    },\n    left: {\n      width: (refRect.left ?? 0) - (boundaries?.left ?? 0),\n      height: boundaries?.height ?? 0\n    }\n  };\n  const sortedAreas = Object.keys(rects).map(key => ({\n    position: key,\n    ...rects[key],\n    area: getArea(rects[key])\n  })).sort((a, b) => b.area - a.area);\n  let filteredAreas = sortedAreas.filter(({\n    width,\n    height\n  }) => {\n    return width >= target.clientWidth && height >= target.clientHeight;\n  });\n  filteredAreas = filteredAreas.filter(({\n    position\n  }) => {\n    return allowedPositions.some(allowedPosition => {\n      return allowedPosition === position;\n    });\n  });\n  const computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].position : sortedAreas[0].position;\n  const variation = placement.split(' ')[1]; // for tooltip on auto position\n\n  target.className = target.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${getBsVer().isBs5 ? PlacementForBs5[computedPlacement] : computedPlacement}`);\n  return computedPlacement + (variation ? `-${variation}` : '');\n}\n\nfunction getOffsets(data) {\n  return {\n    width: data.offsets.target.width,\n    height: data.offsets.target.height,\n    left: Math.floor(data.offsets.target.left ?? 0),\n    top: Math.round(data.offsets.target.top ?? 0),\n    bottom: Math.round(data.offsets.target.bottom ?? 0),\n    right: Math.floor(data.offsets.target.right ?? 0)\n  };\n}\n/**\n * Get the opposite placement of the given one\n */\n\n\nfunction getOppositePlacement(placement) {\n  const hash = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\n}\n/**\n * Get the opposite placement variation of the given one\n */\n\n\nfunction getOppositeVariation(variation) {\n  if (variation === 'right') {\n    return 'left';\n  } else if (variation === 'left') {\n    return 'right';\n  }\n\n  return variation;\n}\n\nconst parse = (value, def = 0) => value ? parseFloat(value) : def;\n\nfunction getOuterSizes(element) {\n  const window = element.ownerDocument.defaultView;\n  const styles = window?.getComputedStyle(element);\n  const x = parse(styles?.marginTop) + parse(styles?.marginBottom);\n  const y = parse(styles?.marginLeft) + parse(styles?.marginRight);\n  return {\n    width: Number(element.offsetWidth) + y,\n    height: Number(element.offsetHeight) + x\n  };\n}\n/**\n * Get offsets to the reference element\n */\n\n\nfunction getReferenceOffsets(target, host, fixedPosition) {\n  const commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n  return getOffsetRectRelativeToArbitraryNode(host, commonOffsetParent, fixedPosition);\n}\n/**\n * Get offsets to the target\n */\n\n\nfunction getTargetOffsets(target, hostOffsets, position) {\n  const placement = position.split(' ')[0]; // Get target node sizes\n\n  const targetRect = getOuterSizes(target); // Add position, width and height to our offsets object\n\n  const targetOffsets = {\n    width: targetRect.width,\n    height: targetRect.height\n  }; // depending by the target placement we have to compute its offsets slightly differently\n\n  const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  const mainSide = isHoriz ? 'top' : 'left';\n  const secondarySide = isHoriz ? 'left' : 'top';\n  const measurement = isHoriz ? 'height' : 'width';\n  const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n  targetOffsets[mainSide] = (hostOffsets[mainSide] ?? 0) + hostOffsets[measurement] / 2 - targetRect[measurement] / 2;\n  targetOffsets[secondarySide] = placement === secondarySide ? (hostOffsets[secondarySide] ?? 0) - targetRect[secondaryMeasurement] : hostOffsets[getOppositePlacement(secondarySide)] ?? 0;\n  return targetOffsets;\n}\n\nfunction isModifierEnabled(options, modifierName) {\n  return !!options.modifiers[modifierName]?.enabled;\n}\n\nconst availablePositions = {\n  top: ['top', 'top start', 'top end'],\n  bottom: ['bottom', 'bottom start', 'bottom end'],\n  start: ['start', 'start top', 'start bottom'],\n  end: ['end', 'end top', 'end bottom']\n};\n\nfunction checkPopoverMargin(placement, checkPosition) {\n  if (!getBsVer().isBs5) {\n    return false;\n  }\n\n  return availablePositions[checkPosition].includes(placement);\n}\n\nfunction checkMargins(placement) {\n  if (!getBsVer().isBs5) {\n    return '';\n  }\n\n  if (checkPopoverMargin(placement, 'end')) {\n    return 'ms-2';\n  }\n\n  if (checkPopoverMargin(placement, 'start')) {\n    return 'me-2';\n  }\n\n  if (checkPopoverMargin(placement, 'top')) {\n    return 'mb-2';\n  }\n\n  if (checkPopoverMargin(placement, 'bottom')) {\n    return 'mt-2';\n  }\n\n  return '';\n}\n\nfunction updateContainerClass(data, renderer) {\n  const target = data.instance.target;\n  let containerClass = target.className;\n  const dataPlacement = getBsVer().isBs5 ? PlacementForBs5[data.placement] : data.placement;\n\n  if (data.placementAuto) {\n    containerClass = containerClass.replace(/bs-popover-auto/g, `bs-popover-${dataPlacement}`);\n    containerClass = containerClass.replace(/ms-2|me-2|mb-2|mt-2/g, '');\n    containerClass = containerClass.replace(/bs-tooltip-auto/g, `bs-tooltip-${dataPlacement}`);\n    containerClass = containerClass.replace(/\\sauto/g, ` ${dataPlacement}`);\n\n    if (containerClass.indexOf('popover') !== -1) {\n      containerClass = containerClass + ' ' + checkMargins(dataPlacement);\n    }\n\n    if (containerClass.indexOf('popover') !== -1 && containerClass.indexOf('popover-auto') === -1) {\n      containerClass += ' popover-auto';\n    }\n\n    if (containerClass.indexOf('tooltip') !== -1 && containerClass.indexOf('tooltip-auto') === -1) {\n      containerClass += ' tooltip-auto';\n    }\n  }\n\n  containerClass = containerClass.replace(/left|right|top|bottom|end|start/g, `${dataPlacement.split(' ')[0]}`);\n\n  if (renderer) {\n    renderer.setAttribute(target, 'class', containerClass);\n    return;\n  }\n\n  target.className = containerClass;\n}\n\nfunction setStyles(element, styles, renderer) {\n  if (!element || !styles) {\n    return;\n  }\n\n  Object.keys(styles).forEach(prop => {\n    let unit = ''; // add unit if the value is numeric and is one of the following\n\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n\n    if (renderer) {\n      renderer.setStyle(element, prop, `${String(styles[prop])}${unit}`);\n      return;\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    element.style[prop] = String(styles[prop]) + unit;\n  });\n}\n\nfunction arrow(data) {\n  let targetOffsets = data.offsets.target; // if arrowElement is a string, suppose it's a CSS selector\n\n  const arrowElement = data.instance.target.querySelector('.arrow'); // if arrowElement is not found, don't run the modifier\n\n  if (!arrowElement) {\n    return data;\n  }\n\n  const isVertical = ['left', 'right'].indexOf(data.placement.split(' ')[0]) !== -1;\n  const len = isVertical ? 'height' : 'width';\n  const sideCapitalized = isVertical ? 'Top' : 'Left';\n  const side = sideCapitalized.toLowerCase();\n  const altSide = isVertical ? 'left' : 'top';\n  const opSide = isVertical ? 'bottom' : 'right';\n  const arrowElementSize = getOuterSizes(arrowElement)[len];\n  const placementVariation = data.placement.split(' ')[1]; // top/left side\n\n  if ((data.offsets.host[opSide] ?? 0) - arrowElementSize < (targetOffsets[side] ?? 0)) {\n    targetOffsets[side] -= (targetOffsets[side] ?? 0) - ((data.offsets.host[opSide] ?? 0) - arrowElementSize);\n  } // bottom/right side\n\n\n  if (Number(data.offsets.host[side]) + Number(arrowElementSize) > (targetOffsets[opSide] ?? 0)) {\n    targetOffsets[side] += Number(data.offsets.host[side]) + Number(arrowElementSize) - Number(targetOffsets[opSide]);\n  }\n\n  targetOffsets = getClientRect(targetOffsets); // Compute the sideValue using the updated target offsets\n  // take target margin in account because we don't have this info available\n\n  const css = getStyleComputedProperty(data.instance.target);\n  const targetMarginSide = parseFloat(css[`margin${sideCapitalized}`]) || 0;\n  const targetBorderSide = parseFloat(css[`border${sideCapitalized}Width`]) || 0; // compute center of the target\n\n  let center;\n\n  if (!placementVariation) {\n    center = Number(data.offsets.host[side]) + Number(data.offsets.host[len] / 2 - arrowElementSize / 2);\n  } else {\n    const targetBorderRadius = parseFloat(css[\"borderRadius\"]) || 0;\n    const targetSideArrowOffset = Number(targetMarginSide + targetBorderSide + targetBorderRadius);\n    center = side === placementVariation ? Number(data.offsets.host[side]) + targetSideArrowOffset : Number(data.offsets.host[side]) + Number(data.offsets.host[len] - targetSideArrowOffset);\n  }\n\n  let sideValue = center - (targetOffsets[side] ?? 0) - targetMarginSide - targetBorderSide; // prevent arrowElement from being placed not contiguously to its target\n\n  sideValue = Math.max(Math.min(targetOffsets[len] - (arrowElementSize + 5), sideValue), 0);\n  data.offsets.arrow = {\n    [side]: Math.round(sideValue),\n    [altSide]: '' // make sure to unset any eventual altSide value from the DOM node\n\n  };\n  data.instance.arrow = arrowElement;\n  return data;\n}\n\nfunction flip(data) {\n  data.offsets.target = getClientRect(data.offsets.target);\n\n  if (!isModifierEnabled(data.options, 'flip')) {\n    data.offsets.target = { ...data.offsets.target,\n      ...getTargetOffsets(data.instance.target, data.offsets.host, data.placement)\n    };\n    return data;\n  }\n\n  const boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n  'viewport', false // positionFixed\n  );\n  let placement = data.placement.split(' ')[0];\n  let variation = data.placement.split(' ')[1] || '';\n  const offsetsHost = data.offsets.host;\n  const target = data.instance.target;\n  const host = data.instance.host;\n  const adaptivePosition = computeAutoPlacement('auto', offsetsHost, target, host, data.options.allowedPositions);\n  const flipOrder = [placement, adaptivePosition];\n  flipOrder.forEach((step, index) => {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return;\n    }\n\n    placement = data.placement.split(' ')[0]; // using floor because the host offsets may contain decimals we are not going to consider here\n\n    const overlapsRef = placement === 'left' && Math.floor(data.offsets.target.right ?? 0) > Math.floor(data.offsets.host.left ?? 0) || placement === 'right' && Math.floor(data.offsets.target.left ?? 0) < Math.floor(data.offsets.host.right ?? 0) || placement === 'top' && Math.floor(data.offsets.target.bottom ?? 0) > Math.floor(data.offsets.host.top ?? 0) || placement === 'bottom' && Math.floor(data.offsets.target.top ?? 0) < Math.floor(data.offsets.host.bottom ?? 0);\n    const overflowsLeft = Math.floor(data.offsets.target.left ?? 0) < Math.floor(boundaries.left ?? 0);\n    const overflowsRight = Math.floor(data.offsets.target.right ?? 0) > Math.floor(boundaries.right ?? 0);\n    const overflowsTop = Math.floor(data.offsets.target.top ?? 0) < Math.floor(boundaries.top ?? 0);\n    const overflowsBottom = Math.floor(data.offsets.target.bottom ?? 0) > Math.floor(boundaries.bottom ?? 0);\n    const overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom; // flip the variation if required\n\n    const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    const flippedVariation = isVertical && variation === 'left' && overflowsLeft || isVertical && variation === 'right' && overflowsRight || !isVertical && variation === 'left' && overflowsTop || !isVertical && variation === 'right' && overflowsBottom;\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? ` ${variation}` : '');\n      data.offsets.target = { ...data.offsets.target,\n        ...getTargetOffsets(data.instance.target, data.offsets.host, data.placement)\n      };\n    }\n  });\n  return data;\n}\n\nfunction initData(targetElement, hostElement, position, options) {\n  if (!targetElement || !hostElement) {\n    return;\n  }\n\n  const hostElPosition = getReferenceOffsets(targetElement, hostElement);\n\n  if (!position.match(/^(auto)*\\s*(left|right|top|bottom|start|end)*$/) && !position.match(/^(left|right|top|bottom|start|end)*(?: (left|right|top|bottom|start|end))*$/)) {\n    position = 'auto';\n  }\n\n  const placementAuto = !!position.match(/auto/g); // support old placements 'auto left|right|top|bottom'\n\n  let placement = position.match(/auto\\s(left|right|top|bottom|start|end)/) ? position.split(' ')[1] || 'auto' : position; // Normalize placements that have identical main placement and variation (\"right right\" => \"right\").\n\n  const matches = placement.match(/^(left|right|top|bottom|start|end)* ?(?!\\1)(left|right|top|bottom|start|end)?/);\n\n  if (matches) {\n    placement = matches[1] + (matches[2] ? ` ${matches[2]}` : '');\n  } // \"left right\", \"top bottom\" etc. placements also considered incorrect.\n\n\n  if (['left right', 'right left', 'top bottom', 'bottom top'].indexOf(placement) !== -1) {\n    placement = 'auto';\n  }\n\n  placement = computeAutoPlacement(placement, hostElPosition, targetElement, hostElement, options ? options.allowedPositions : undefined);\n  const targetOffset = getTargetOffsets(targetElement, hostElPosition, placement);\n  return {\n    options: options || {\n      modifiers: {}\n    },\n    instance: {\n      target: targetElement,\n      host: hostElement,\n      arrow: void 0\n    },\n    offsets: {\n      target: targetOffset,\n      host: hostElPosition,\n      arrow: void 0\n    },\n    positionFixed: false,\n    placement,\n    placementAuto\n  };\n}\n\nfunction preventOverflow(data) {\n  if (!isModifierEnabled(data.options, 'preventOverflow')) {\n    return data;\n  } // NOTE: DOM access here\n  // resets the target Offsets's position so that the document size can be calculated excluding\n  // the size of the targetOffsets element itself\n\n\n  const transformProp = 'transform';\n  const targetStyles = data.instance.target.style; // assignment to help minification\n\n  const {\n    top,\n    left,\n    [transformProp]: transform\n  } = targetStyles;\n  targetStyles.top = '';\n  targetStyles.left = '';\n  targetStyles[transformProp] = '';\n  const boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n  data.options.modifiers.preventOverflow?.boundariesElement || 'scrollParent', false // positionFixed\n  ); // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n\n  targetStyles.top = top;\n  targetStyles.left = left;\n  targetStyles[transformProp] = transform;\n  const order = ['left', 'right', 'top', 'bottom'];\n  const check = {\n    primary(placement) {\n      let value = data.offsets.target[placement]; // options.escapeWithReference\n\n      if ((data.offsets.target[placement] ?? 0) < (boundaries[placement] ?? 0)) {\n        value = Math.max(data.offsets.target[placement] ?? 0, boundaries[placement] ?? 0);\n      }\n\n      return {\n        [placement]: value\n      };\n    },\n\n    secondary(placement) {\n      const isPlacementHorizontal = placement === 'right';\n      const mainSide = isPlacementHorizontal ? 'left' : 'top';\n      const measurement = isPlacementHorizontal ? 'width' : 'height';\n      let value = data.offsets.target[mainSide]; // escapeWithReference\n\n      if ((data.offsets.target[placement] ?? 0) > (boundaries[placement] ?? 0)) {\n        value = Math.min(data.offsets.target[mainSide] ?? 0, (boundaries[placement] ?? 0) - data.offsets.target[measurement]);\n      }\n\n      return {\n        [mainSide]: value\n      };\n    }\n\n  };\n  order.forEach(placement => {\n    const side = ['left', 'top', 'start'].indexOf(placement) !== -1 ? check['primary'] : check['secondary'];\n    data.offsets.target = { ...data.offsets.target,\n      ...side(placement)\n    };\n  });\n  return data;\n}\n\nfunction shift(data) {\n  const placement = data.placement;\n  const basePlacement = placement.split(' ')[0];\n  const shiftVariation = placement.split(' ')[1];\n\n  if (shiftVariation) {\n    const {\n      host,\n      target\n    } = data.offsets;\n    const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    const side = isVertical ? 'left' : 'top';\n    const measurement = isVertical ? 'width' : 'height';\n    const shiftOffsets = {\n      start: {\n        [side]: host[side]\n      },\n      end: {\n        [side]: (host[side] ?? 0) + host[measurement] - target[measurement]\n      }\n    };\n    data.offsets.target = { ...target,\n      ...{\n        [side]: side === shiftVariation ? shiftOffsets.start[side] : shiftOffsets.end[side]\n      }\n    };\n  }\n\n  return data;\n}\n\nclass Positioning {\n  position(hostElement, targetElement\n  /*, round = true*/\n  ) {\n    return this.offset(hostElement, targetElement\n    /*, false*/\n    );\n  }\n\n  offset(hostElement, targetElement\n  /*, round = true*/\n  ) {\n    return getReferenceOffsets(targetElement, hostElement);\n  }\n\n  positionElements(hostElement, targetElement, position, appendToBody, options) {\n    const chainOfModifiers = [flip, shift, preventOverflow, arrow];\n    const _position = MapPlacementInToRL[position];\n    const data = initData(targetElement, hostElement, _position, options);\n\n    if (!data) {\n      return;\n    }\n\n    return chainOfModifiers.reduce((modifiedData, modifier) => modifier(modifiedData), data);\n  }\n\n}\n\nconst positionService = new Positioning();\n\nfunction positionElements(hostElement, targetElement, placement, appendToBody, options, renderer) {\n  const data = positionService.positionElements(hostElement, targetElement, placement, appendToBody, options);\n\n  if (!data) {\n    return;\n  }\n\n  const offsets = getOffsets(data);\n  setStyles(targetElement, {\n    'will-change': 'transform',\n    top: '0px',\n    left: '0px',\n    transform: `translate3d(${offsets.left}px, ${offsets.top}px, 0px)`\n  }, renderer);\n\n  if (data.instance.arrow) {\n    setStyles(data.instance.arrow, data.offsets.arrow, renderer);\n  }\n\n  updateContainerClass(data, renderer);\n}\n\nclass PositioningService {\n  constructor(ngZone, rendererFactory, platformId) {\n    this.update$$ = new Subject();\n    this.positionElements = new Map();\n    this.isDisabled = false;\n\n    if (isPlatformBrowser(platformId)) {\n      ngZone.runOutsideAngular(() => {\n        this.triggerEvent$ = merge(fromEvent(window, 'scroll', {\n          passive: true\n        }), fromEvent(window, 'resize', {\n          passive: true\n        }), of(0, animationFrameScheduler), this.update$$);\n        this.triggerEvent$.subscribe(() => {\n          if (this.isDisabled) {\n            return;\n          }\n\n          this.positionElements // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          .forEach(positionElement => {\n            positionElements(_getHtmlElement(positionElement.target), _getHtmlElement(positionElement.element), positionElement.attachment, positionElement.appendToBody, this.options, rendererFactory.createRenderer(null, null));\n          });\n        });\n      });\n    }\n  }\n\n  position(options) {\n    this.addPositionElement(options);\n  }\n\n  get event$() {\n    return this.triggerEvent$;\n  }\n\n  disable() {\n    this.isDisabled = true;\n  }\n\n  enable() {\n    this.isDisabled = false;\n  }\n\n  addPositionElement(options) {\n    this.positionElements.set(_getHtmlElement(options.element), options);\n  }\n\n  calcPosition() {\n    this.update$$.next(null);\n  }\n\n  deletePositionElement(elRef) {\n    this.positionElements.delete(_getHtmlElement(elRef));\n  }\n\n  setOptions(options) {\n    this.options = options;\n  }\n\n}\n\nPositioningService.ɵfac = function PositioningService_Factory(t) {\n  return new (t || PositioningService)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i0.RendererFactory2), i0.ɵɵinject(PLATFORM_ID));\n};\n\nPositioningService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PositioningService,\n  factory: PositioningService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PositioningService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.NgZone\n    }, {\n      type: i0.RendererFactory2\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n\nfunction _getHtmlElement(element) {\n  // it means that we got a selector\n  if (typeof element === 'string') {\n    return document.querySelector(element);\n  }\n\n  if (element instanceof ElementRef) {\n    return element.nativeElement;\n  }\n\n  return element ?? null;\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { PlacementForBs5, Positioning, PositioningService, checkMargins, positionElements };","map":{"version":3,"names":["getBsVer","i0","PLATFORM_ID","Injectable","Inject","ElementRef","isPlatformBrowser","Subject","merge","fromEvent","of","animationFrameScheduler","MapPlacementInToRL","PlacementForBs5","getStyleComputedProperty","element","property","nodeType","window","ownerDocument","defaultView","css","getComputedStyle","getOffsetParent","document","documentElement","noOffsetParent","offsetParent","sibling","nextElementSibling","nodeName","indexOf","isOffsetContainer","firstElementChild","getRoot","node","parentNode","findCommonOffsetParent","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","element1root","host","getFixedPositionOffsetParent","parentElement","el","getBordersSize","styles","axis","sideA","sideB","parseFloat","getSize","body","html","computedStyle","_body","_html","_computedStyle","Math","max","getWindowSizes","height","width","getClientRect","offsets","right","left","bottom","top","isNumeric","n","isNaN","isFinite","Number","isNumber","value","Object","prototype","toString","call","getBoundingClientRect","rect","result","sizes","undefined","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","getParentNode","getScrollParent","overflow","overflowX","overflowY","test","String","getOffsetRectRelativeToArbitraryNode","children","parent","fixedPosition","isHTML","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","getScroll","side","upperSide","scrollingElement","getViewportOffsetRectRelativeToArtbitraryNode","excludeScroll","relativeOffset","innerWidth","innerHeight","scrollTop","scrollLeft","offset","isFixed","getBoundaries","target","padding","boundariesElement","boundaries","boundariesNode","getArea","computeAutoPlacement","placement","refRect","allowedPositions","rects","sortedAreas","keys","map","key","position","area","sort","a","b","filteredAreas","filter","some","allowedPosition","computedPlacement","length","variation","split","className","replace","isBs5","getOffsets","data","floor","round","getOppositePlacement","hash","matched","getOppositeVariation","parse","def","getOuterSizes","x","marginBottom","y","marginRight","getReferenceOffsets","commonOffsetParent","getTargetOffsets","hostOffsets","targetRect","targetOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","isModifierEnabled","options","modifierName","modifiers","enabled","availablePositions","checkPopoverMargin","checkPosition","includes","checkMargins","updateContainerClass","renderer","instance","containerClass","dataPlacement","placementAuto","setAttribute","setStyles","forEach","prop","unit","setStyle","style","arrow","arrowElement","querySelector","isVertical","len","sideCapitalized","toLowerCase","altSide","opSide","arrowElementSize","placementVariation","targetMarginSide","targetBorderSide","center","targetBorderRadius","targetSideArrowOffset","sideValue","min","flip","offsetsHost","adaptivePosition","flipOrder","step","index","overlapsRef","overflowsLeft","overflowsRight","overflowsTop","overflowsBottom","overflowsBoundaries","flippedVariation","initData","targetElement","hostElement","hostElPosition","match","matches","targetOffset","positionFixed","preventOverflow","transformProp","targetStyles","transform","check","primary","secondary","isPlacementHorizontal","shift","basePlacement","shiftVariation","shiftOffsets","Positioning","positionElements","appendToBody","chainOfModifiers","_position","reduce","modifiedData","modifier","positionService","PositioningService","constructor","ngZone","rendererFactory","platformId","update$$","Map","isDisabled","runOutsideAngular","triggerEvent$","passive","subscribe","positionElement","_getHtmlElement","attachment","createRenderer","addPositionElement","event$","disable","enable","set","calcPosition","next","deletePositionElement","elRef","delete","setOptions","ɵfac","NgZone","RendererFactory2","ɵprov","type","args","providedIn","decorators","nativeElement"],"sources":["C:/Users/ASUS/Documents/GitHub/ChromaticBotFrontEnd/node_modules/ngx-bootstrap/positioning/fesm2020/ngx-bootstrap-positioning.mjs"],"sourcesContent":["import { getBsVer } from 'ngx-bootstrap/utils';\nimport * as i0 from '@angular/core';\nimport { PLATFORM_ID, Injectable, Inject, ElementRef } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, merge, fromEvent, of, animationFrameScheduler } from 'rxjs';\n\nvar MapPlacementInToRL;\n(function (MapPlacementInToRL) {\n    MapPlacementInToRL[\"top\"] = \"top\";\n    MapPlacementInToRL[\"bottom\"] = \"bottom\";\n    MapPlacementInToRL[\"left\"] = \"left\";\n    MapPlacementInToRL[\"right\"] = \"right\";\n    MapPlacementInToRL[\"auto\"] = \"auto\";\n    MapPlacementInToRL[\"end\"] = \"right\";\n    MapPlacementInToRL[\"start\"] = \"left\";\n    MapPlacementInToRL[\"top left\"] = \"top left\";\n    MapPlacementInToRL[\"top right\"] = \"top right\";\n    MapPlacementInToRL[\"right top\"] = \"right top\";\n    MapPlacementInToRL[\"right bottom\"] = \"right bottom\";\n    MapPlacementInToRL[\"bottom right\"] = \"bottom right\";\n    MapPlacementInToRL[\"bottom left\"] = \"bottom left\";\n    MapPlacementInToRL[\"left bottom\"] = \"left bottom\";\n    MapPlacementInToRL[\"left top\"] = \"left top\";\n    MapPlacementInToRL[\"top start\"] = \"top left\";\n    MapPlacementInToRL[\"top end\"] = \"top right\";\n    MapPlacementInToRL[\"end top\"] = \"right top\";\n    MapPlacementInToRL[\"end bottom\"] = \"right bottom\";\n    MapPlacementInToRL[\"bottom end\"] = \"bottom right\";\n    MapPlacementInToRL[\"bottom start\"] = \"bottom left\";\n    MapPlacementInToRL[\"start bottom\"] = \"start bottom\";\n    MapPlacementInToRL[\"start top\"] = \"left top\";\n})(MapPlacementInToRL || (MapPlacementInToRL = {}));\nvar PlacementForBs5;\n(function (PlacementForBs5) {\n    PlacementForBs5[\"top\"] = \"top\";\n    PlacementForBs5[\"bottom\"] = \"bottom\";\n    PlacementForBs5[\"left\"] = \"start\";\n    PlacementForBs5[\"right\"] = \"end\";\n    PlacementForBs5[\"auto\"] = \"auto\";\n    PlacementForBs5[\"end\"] = \"end\";\n    PlacementForBs5[\"start\"] = \"start\";\n    PlacementForBs5[\"top left\"] = \"top start\";\n    PlacementForBs5[\"top right\"] = \"top end\";\n    PlacementForBs5[\"right top\"] = \"end top\";\n    PlacementForBs5[\"right bottom\"] = \"end bottom\";\n    PlacementForBs5[\"bottom right\"] = \"bottom end\";\n    PlacementForBs5[\"bottom left\"] = \"bottom start\";\n    PlacementForBs5[\"left bottom\"] = \"start bottom\";\n    PlacementForBs5[\"left top\"] = \"start top\";\n    PlacementForBs5[\"top start\"] = \"top start\";\n    PlacementForBs5[\"top end\"] = \"top end\";\n    PlacementForBs5[\"end top\"] = \"end top\";\n    PlacementForBs5[\"end bottom\"] = \"end bottom\";\n    PlacementForBs5[\"bottom end\"] = \"bottom end\";\n    PlacementForBs5[\"bottom start\"] = \"bottom start\";\n    PlacementForBs5[\"start bottom\"] = \"start bottom\";\n    PlacementForBs5[\"start top\"] = \"start top\";\n})(PlacementForBs5 || (PlacementForBs5 = {}));\n\nfunction getStyleComputedProperty(element, property) {\n    if (element.nodeType !== 1) {\n        return [];\n    }\n    // NOTE: 1 DOM access here\n    const window = element.ownerDocument.defaultView;\n    const css = window?.getComputedStyle(element, null);\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return property ? css && css[property] : css;\n}\n\n/**\n * Returns the offset parent of the given element\n */\nfunction getOffsetParent(element) {\n    if (!element) {\n        return document.documentElement;\n    }\n    const noOffsetParent = null;\n    // NOTE: 1 DOM access here\n    let offsetParent = element?.offsetParent;\n    // Skip hidden elements which don't have an offsetParent\n    let sibling = void 0;\n    while (offsetParent === noOffsetParent\n        && element.nextElementSibling\n        && sibling !== element.nextElementSibling) {\n        // todo: valorkin fix\n        sibling = element.nextElementSibling;\n        offsetParent = sibling.offsetParent;\n    }\n    const nodeName = offsetParent && offsetParent.nodeName;\n    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n        return sibling ? sibling.ownerDocument.documentElement : document.documentElement;\n    }\n    // .offsetParent will return the closest TH, TD or TABLE in case\n    if (offsetParent &&\n        ['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 &&\n        getStyleComputedProperty(offsetParent, 'position') === 'static') {\n        return getOffsetParent(offsetParent);\n    }\n    return offsetParent;\n}\n\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isOffsetContainer(element) {\n    const { nodeName } = element;\n    if (nodeName === 'BODY') {\n        return false;\n    }\n    return (nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element);\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n */\nfunction getRoot(node) {\n    if (node.parentNode !== null) {\n        return getRoot(node.parentNode);\n    }\n    return node;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n */\nfunction findCommonOffsetParent(element1, element2) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n        return document.documentElement;\n    }\n    // Here we make sure to give as \"start\" the element that comes first in the DOM\n    const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n    const start = order ? element1 : element2;\n    const end = order ? element2 : element1;\n    // Get common ancestor container\n    const range = document.createRange();\n    range.setStart(start, 0);\n    range.setEnd(end, 0);\n    // todo: valorkin fix\n    const commonAncestorContainer = range.commonAncestorContainer;\n    // Both nodes are inside #document\n    if ((element1 !== commonAncestorContainer &&\n        element2 !== commonAncestorContainer) ||\n        start.contains(end)) {\n        if (isOffsetContainer(commonAncestorContainer)) {\n            return commonAncestorContainer;\n        }\n        return getOffsetParent(commonAncestorContainer);\n    }\n    // one of the nodes is inside shadowDOM, find which one\n    const element1root = getRoot(element1);\n    if (element1root.host) {\n        return findCommonOffsetParent(element1root.host, element2);\n    }\n    else {\n        return findCommonOffsetParent(element1, getRoot(element2).host);\n    }\n}\n\n/**\n * Finds the first parent of an element that has a transformed property defined\n */\nfunction getFixedPositionOffsetParent(element) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element || !element.parentElement) {\n        return document.documentElement;\n    }\n    let el = element.parentElement;\n    while (el?.parentElement && getStyleComputedProperty(el, 'transform') === 'none') {\n        el = el.parentElement;\n    }\n    return el || document.documentElement;\n}\n\n/**\n * Helper to detect borders of a given element\n */\nfunction getBordersSize(styles, axis) {\n    const sideA = axis === 'x' ? 'Left' : 'Top';\n    const sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n    return (parseFloat(styles[`border${sideA}Width`]) +\n        parseFloat(styles[`border${sideB}Width`]));\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n    const _body = body;\n    const _html = html;\n    const _computedStyle = computedStyle;\n    return Math.max(_body[`offset${axis}`], _body[`scroll${axis}`], _html[`client${axis}`], _html[`offset${axis}`], _html[`scroll${axis}`], 0);\n}\nfunction getWindowSizes(document) {\n    const body = document.body;\n    const html = document.documentElement;\n    const computedStyle = void 0;\n    return {\n        height: getSize('Height', body, html, computedStyle),\n        width: getSize('Width', body, html, computedStyle)\n    };\n}\n\nfunction getClientRect(offsets) {\n    return {\n        ...offsets,\n        right: (offsets.left || 0) + offsets.width,\n        bottom: (offsets.top || 0) + offsets.height\n    };\n}\n\n/**\n * Tells if a given input is a number\n */\nfunction isNumeric(n) {\n    return n !== '' && !isNaN(parseFloat(n)) && isFinite(Number(n));\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isNumber(value) {\n    return typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]';\n}\n\n/**\n * Get bounding client rect of given element\n */\nfunction getBoundingClientRect(element) {\n    const rect = element.getBoundingClientRect();\n    // IE10 10 FIX: Please, don't ask, the element isn't\n    // considered in DOM in some circumstances...\n    // This isn't reproducible in IE10 compatibility mode of IE11\n    // try {\n    //   if (isIE(10)) {\n    //     const scrollTop = getScroll(element, 'top');\n    //     const scrollLeft = getScroll(element, 'left');\n    //     if (rect && isNumber(rect.top) && isNumber(rect.left) && isNumber(rect.bottom) && isNumber(rect.right)) {\n    //       rect.top += scrollTop;\n    //       rect.left += scrollLeft;\n    //       rect.bottom += scrollTop;\n    //       rect.right += scrollLeft;\n    //     }\n    //   }\n    // } catch (e) {\n    //   return rect;\n    // }\n    if (!(rect && isNumber(rect.top) && isNumber(rect.left) && isNumber(rect.bottom) && isNumber(rect.right))) {\n        return rect;\n    }\n    const result = {\n        left: rect.left,\n        top: rect.top,\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n    };\n    // subtract scrollbar size from sizes\n    const sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : undefined;\n    const width = sizes?.width || element.clientWidth\n        || isNumber(rect.right) && isNumber(result.left) && rect.right - result.left || 0;\n    const height = sizes?.height || element.clientHeight\n        || isNumber(rect.bottom) && isNumber(result.top) && rect.bottom - result.top || 0;\n    let horizScrollbar = element.offsetWidth - width;\n    let vertScrollbar = element.offsetHeight - height;\n    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n    // we make this check conditional for performance reasons\n    if (horizScrollbar || vertScrollbar) {\n        const styles = getStyleComputedProperty(element);\n        horizScrollbar -= getBordersSize(styles, 'x');\n        vertScrollbar -= getBordersSize(styles, 'y');\n        result.width -= horizScrollbar;\n        result.height -= vertScrollbar;\n    }\n    return getClientRect(result);\n}\n\n/**\n * Returns the parentNode or the host of the element\n */\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getParentNode(element) {\n    if (element.nodeName === 'HTML') {\n        return element;\n    }\n    return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n */\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getScrollParent(element) {\n    // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n    if (!element) {\n        return document.body;\n    }\n    switch (element.nodeName) {\n        case 'HTML':\n        case 'BODY':\n            return element.ownerDocument.body;\n        case '#document':\n            return element.body;\n        default:\n    }\n    // Firefox want us to check `-x` and `-y` variations as well\n    const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n    if (/(auto|scroll|overlay)/.test(String(overflow) + String(overflowY) + String(overflowX))) {\n        return element;\n    }\n    return getScrollParent(getParentNode(element));\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent, fixedPosition = false) {\n    const isHTML = parent.nodeName === 'HTML';\n    const childrenRect = getBoundingClientRect(children);\n    const parentRect = getBoundingClientRect(parent);\n    const scrollParent = getScrollParent(children);\n    const styles = getStyleComputedProperty(parent);\n    const borderTopWidth = parseFloat(styles.borderTopWidth);\n    const borderLeftWidth = parseFloat(styles.borderLeftWidth);\n    // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n    if (fixedPosition && isHTML) {\n        parentRect.top = Math.max(parentRect.top ?? 0, 0);\n        parentRect.left = Math.max(parentRect.left ?? 0, 0);\n    }\n    const offsets = getClientRect({\n        top: (childrenRect.top ?? 0) - (parentRect.top ?? 0) - borderTopWidth,\n        left: (childrenRect.left ?? 0) - (parentRect.left ?? 0) - borderLeftWidth,\n        width: childrenRect.width,\n        height: childrenRect.height\n    });\n    offsets.marginTop = 0;\n    offsets.marginLeft = 0;\n    // Subtract margins of documentElement in case it's being used as parent\n    // we do this only on HTML because it's the only element that behaves\n    // differently when margins are applied to it. The margins are included in\n    // the box of the documentElement, in the other cases not.\n    if (isHTML) {\n        const marginTop = parseFloat(styles.marginTop);\n        const marginLeft = parseFloat(styles.marginLeft);\n        if (isNumber(offsets.top)) {\n            offsets.top -= borderTopWidth - marginTop;\n        }\n        if (isNumber(offsets.bottom)) {\n            offsets.bottom -= borderTopWidth - marginTop;\n        }\n        if (isNumber(offsets.left)) {\n            offsets.left -= borderLeftWidth - marginLeft;\n        }\n        if (isNumber(offsets.right)) {\n            offsets.right -= borderLeftWidth - marginLeft;\n        }\n        // Attach marginTop and marginLeft because in some circumstances we may need them\n        offsets.marginTop = marginTop;\n        offsets.marginLeft = marginLeft;\n    }\n    return offsets;\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n */\nfunction getScroll(element, side = 'top') {\n    const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n    const nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n        const html = element.ownerDocument.documentElement;\n        const scrollingElement = element.ownerDocument.scrollingElement || html;\n        return scrollingElement[upperSide];\n    }\n    return element[upperSide];\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element, excludeScroll = false) {\n    const html = element.ownerDocument.documentElement;\n    const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n    const width = Math.max(html.clientWidth, window.innerWidth || 0);\n    const height = Math.max(html.clientHeight, window.innerHeight || 0);\n    const scrollTop = !excludeScroll ? getScroll(html) : 0;\n    const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n    const offset = {\n        top: scrollTop - Number(relativeOffset?.top) + Number(relativeOffset?.marginTop),\n        left: scrollLeft - Number(relativeOffset?.left) + Number(relativeOffset?.marginLeft),\n        width,\n        height\n    };\n    return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n */\nfunction isFixed(element) {\n    const nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n        return false;\n    }\n    if (getStyleComputedProperty(element, 'position') === 'fixed') {\n        return true;\n    }\n    return isFixed(getParentNode(element));\n}\n\nfunction getBoundaries(target, host, padding = 0, boundariesElement, fixedPosition = false) {\n    // NOTE: 1 DOM access here\n    let boundaries = { top: 0, left: 0 };\n    const offsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n    // Handle viewport case\n    if (boundariesElement === 'viewport') {\n        boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n    }\n    else {\n        // Handle other cases based on DOM element used as boundaries\n        let boundariesNode;\n        if (boundariesElement === 'scrollParent') {\n            boundariesNode = getScrollParent(getParentNode(host));\n            if (boundariesNode.nodeName === 'BODY') {\n                boundariesNode = target.ownerDocument.documentElement;\n            }\n        }\n        else if (boundariesElement === 'window') {\n            boundariesNode = target.ownerDocument.documentElement;\n        }\n        else {\n            boundariesNode = boundariesElement;\n        }\n        const offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n        // In case of HTML, we need a different computation\n        if (offsets && boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n            const { height, width } = getWindowSizes(target.ownerDocument);\n            if (isNumber(boundaries.top) && isNumber(offsets.top) && isNumber(offsets.marginTop)) {\n                boundaries.top += offsets.top - offsets.marginTop;\n            }\n            if (isNumber(boundaries.top)) {\n                boundaries.bottom = Number(height) + Number(offsets.top);\n            }\n            if (isNumber(boundaries.left) && isNumber(offsets.left) && isNumber(offsets.marginLeft)) {\n                boundaries.left += offsets.left - offsets.marginLeft;\n            }\n            if (isNumber(boundaries.top)) {\n                boundaries.right = Number(width) + Number(offsets.left);\n            }\n        }\n        else if (offsets) {\n            // for all the other DOM elements, this one is good\n            boundaries = offsets;\n        }\n    }\n    // Add paddings\n    if (isNumber(boundaries.left)) {\n        boundaries.left += padding;\n    }\n    if (isNumber(boundaries.top)) {\n        boundaries.top += padding;\n    }\n    if (isNumber(boundaries.right)) {\n        boundaries.right -= padding;\n    }\n    if (isNumber(boundaries.bottom)) {\n        boundaries.bottom -= padding;\n    }\n    return boundaries;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n */\nfunction getArea({ width, height }) {\n    return width * height;\n}\nfunction computeAutoPlacement(placement, refRect, target, host, allowedPositions = ['top', 'bottom', 'right', 'left'], boundariesElement = 'viewport', padding = 0) {\n    if (placement.indexOf('auto') === -1) {\n        return placement;\n    }\n    const boundaries = getBoundaries(target, host, padding, boundariesElement);\n    const rects = {\n        top: {\n            width: boundaries?.width ?? 0,\n            height: (refRect?.top ?? 0) - (boundaries?.top ?? 0)\n        },\n        right: {\n            width: (boundaries?.right ?? 0) - (refRect?.right ?? 0),\n            height: boundaries?.height ?? 0\n        },\n        bottom: {\n            width: boundaries?.width ?? 0,\n            height: (boundaries?.bottom ?? 0) - (refRect?.bottom ?? 0)\n        },\n        left: {\n            width: (refRect.left ?? 0) - (boundaries?.left ?? 0),\n            height: boundaries?.height ?? 0\n        }\n    };\n    const sortedAreas = Object.keys(rects)\n        .map((key) => ({\n        position: key,\n        ...rects[key],\n        area: getArea(rects[key])\n    }))\n        .sort((a, b) => b.area - a.area);\n    let filteredAreas = sortedAreas.filter(({ width, height }) => {\n        return width >= target.clientWidth && height >= target.clientHeight;\n    });\n    filteredAreas = filteredAreas.filter(({ position }) => {\n        return allowedPositions.some((allowedPosition) => {\n            return allowedPosition === position;\n        });\n    });\n    const computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].position : sortedAreas[0].position;\n    const variation = placement.split(' ')[1];\n    // for tooltip on auto position\n    target.className = target.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${getBsVer().isBs5 ? PlacementForBs5[computedPlacement] : computedPlacement}`);\n    return computedPlacement + (variation ? `-${variation}` : '');\n}\n\nfunction getOffsets(data) {\n    return {\n        width: data.offsets.target.width,\n        height: data.offsets.target.height,\n        left: Math.floor(data.offsets.target.left ?? 0),\n        top: Math.round(data.offsets.target.top ?? 0),\n        bottom: Math.round(data.offsets.target.bottom ?? 0),\n        right: Math.floor(data.offsets.target.right ?? 0)\n    };\n}\n\n/**\n * Get the opposite placement of the given one\n */\nfunction getOppositePlacement(placement) {\n    const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n    return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\n}\n\n/**\n * Get the opposite placement variation of the given one\n */\nfunction getOppositeVariation(variation) {\n    if (variation === 'right') {\n        return 'left';\n    }\n    else if (variation === 'left') {\n        return 'right';\n    }\n    return variation;\n}\n\nconst parse = (value, def = 0) => value ? parseFloat(value) : def;\nfunction getOuterSizes(element) {\n    const window = element.ownerDocument.defaultView;\n    const styles = window?.getComputedStyle(element);\n    const x = parse(styles?.marginTop) + parse(styles?.marginBottom);\n    const y = parse(styles?.marginLeft) + parse(styles?.marginRight);\n    return {\n        width: Number(element.offsetWidth) + y,\n        height: Number(element.offsetHeight) + x\n    };\n}\n\n/**\n * Get offsets to the reference element\n */\nfunction getReferenceOffsets(target, host, fixedPosition) {\n    const commonOffsetParent = fixedPosition\n        ? getFixedPositionOffsetParent(target)\n        : findCommonOffsetParent(target, host);\n    return getOffsetRectRelativeToArbitraryNode(host, commonOffsetParent, fixedPosition);\n}\n\n/**\n * Get offsets to the target\n */\nfunction getTargetOffsets(target, hostOffsets, position) {\n    const placement = position.split(' ')[0];\n    // Get target node sizes\n    const targetRect = getOuterSizes(target);\n    // Add position, width and height to our offsets object\n    const targetOffsets = {\n        width: targetRect.width,\n        height: targetRect.height\n    };\n    // depending by the target placement we have to compute its offsets slightly differently\n    const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n    const mainSide = isHoriz ? 'top' : 'left';\n    const secondarySide = isHoriz ? 'left' : 'top';\n    const measurement = isHoriz ? 'height' : 'width';\n    const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n    targetOffsets[mainSide] =\n        (hostOffsets[mainSide] ?? 0) +\n            hostOffsets[measurement] / 2 -\n            targetRect[measurement] / 2;\n    targetOffsets[secondarySide] = placement === secondarySide\n        ? (hostOffsets[secondarySide] ?? 0) - targetRect[secondaryMeasurement]\n        : hostOffsets[getOppositePlacement(secondarySide)] ?? 0;\n    return targetOffsets;\n}\n\nfunction isModifierEnabled(options, modifierName) {\n    return !!options.modifiers[modifierName]?.enabled;\n}\n\nconst availablePositions = {\n    top: ['top', 'top start', 'top end'],\n    bottom: ['bottom', 'bottom start', 'bottom end'],\n    start: ['start', 'start top', 'start bottom'],\n    end: ['end', 'end top', 'end bottom']\n};\nfunction checkPopoverMargin(placement, checkPosition) {\n    if (!getBsVer().isBs5) {\n        return false;\n    }\n    return availablePositions[checkPosition].includes(placement);\n}\nfunction checkMargins(placement) {\n    if (!getBsVer().isBs5) {\n        return '';\n    }\n    if (checkPopoverMargin(placement, 'end')) {\n        return 'ms-2';\n    }\n    if (checkPopoverMargin(placement, 'start')) {\n        return 'me-2';\n    }\n    if (checkPopoverMargin(placement, 'top')) {\n        return 'mb-2';\n    }\n    if (checkPopoverMargin(placement, 'bottom')) {\n        return 'mt-2';\n    }\n    return '';\n}\n\nfunction updateContainerClass(data, renderer) {\n    const target = data.instance.target;\n    let containerClass = target.className;\n    const dataPlacement = getBsVer().isBs5 ? PlacementForBs5[data.placement] : data.placement;\n    if (data.placementAuto) {\n        containerClass = containerClass.replace(/bs-popover-auto/g, `bs-popover-${dataPlacement}`);\n        containerClass = containerClass.replace(/ms-2|me-2|mb-2|mt-2/g, '');\n        containerClass = containerClass.replace(/bs-tooltip-auto/g, `bs-tooltip-${dataPlacement}`);\n        containerClass = containerClass.replace(/\\sauto/g, ` ${dataPlacement}`);\n        if (containerClass.indexOf('popover') !== -1) {\n            containerClass = containerClass + ' ' + checkMargins(dataPlacement);\n        }\n        if (containerClass.indexOf('popover') !== -1 && containerClass.indexOf('popover-auto') === -1) {\n            containerClass += ' popover-auto';\n        }\n        if (containerClass.indexOf('tooltip') !== -1 && containerClass.indexOf('tooltip-auto') === -1) {\n            containerClass += ' tooltip-auto';\n        }\n    }\n    containerClass = containerClass.replace(/left|right|top|bottom|end|start/g, `${dataPlacement.split(' ')[0]}`);\n    if (renderer) {\n        renderer.setAttribute(target, 'class', containerClass);\n        return;\n    }\n    target.className = containerClass;\n}\n\nfunction setStyles(element, styles, renderer) {\n    if (!element || !styles) {\n        return;\n    }\n    Object.keys(styles).forEach((prop) => {\n        let unit = '';\n        // add unit if the value is numeric and is one of the following\n        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 &&\n            isNumeric(styles[prop])) {\n            unit = 'px';\n        }\n        if (renderer) {\n            renderer.setStyle(element, prop, `${String(styles[prop])}${unit}`);\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        element.style[prop] = String(styles[prop]) + unit;\n    });\n}\n\nfunction arrow(data) {\n    let targetOffsets = data.offsets.target;\n    // if arrowElement is a string, suppose it's a CSS selector\n    const arrowElement = data.instance.target.querySelector('.arrow');\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n        return data;\n    }\n    const isVertical = ['left', 'right'].indexOf(data.placement.split(' ')[0]) !== -1;\n    const len = isVertical ? 'height' : 'width';\n    const sideCapitalized = isVertical ? 'Top' : 'Left';\n    const side = sideCapitalized.toLowerCase();\n    const altSide = isVertical ? 'left' : 'top';\n    const opSide = isVertical ? 'bottom' : 'right';\n    const arrowElementSize = getOuterSizes(arrowElement)[len];\n    const placementVariation = data.placement.split(' ')[1];\n    // top/left side\n    if ((data.offsets.host[opSide] ?? 0) - arrowElementSize < (targetOffsets[side] ?? 0)) {\n        (targetOffsets)[side] -=\n            (targetOffsets[side] ?? 0) - ((data.offsets.host[opSide] ?? 0) - arrowElementSize);\n    }\n    // bottom/right side\n    if (Number((data).offsets.host[side]) + Number(arrowElementSize) > (targetOffsets[opSide] ?? 0)) {\n        (targetOffsets)[side] +=\n            Number((data).offsets.host[side]) + Number(arrowElementSize) - Number((targetOffsets)[opSide]);\n    }\n    targetOffsets = getClientRect(targetOffsets);\n    // Compute the sideValue using the updated target offsets\n    // take target margin in account because we don't have this info available\n    const css = getStyleComputedProperty(data.instance.target);\n    const targetMarginSide = parseFloat(css[`margin${sideCapitalized}`]) || 0;\n    const targetBorderSide = parseFloat(css[`border${sideCapitalized}Width`]) || 0;\n    // compute center of the target\n    let center;\n    if (!placementVariation) {\n        center = Number((data).offsets.host[side]) + Number(data.offsets.host[len] / 2 - arrowElementSize / 2);\n    }\n    else {\n        const targetBorderRadius = parseFloat(css[\"borderRadius\"]) || 0;\n        const targetSideArrowOffset = Number(targetMarginSide + targetBorderSide + targetBorderRadius);\n        center = side === placementVariation ?\n            Number((data).offsets.host[side]) + targetSideArrowOffset :\n            Number((data).offsets.host[side]) + Number(data.offsets.host[len] - targetSideArrowOffset);\n    }\n    let sideValue = center - (targetOffsets[side] ?? 0) - targetMarginSide - targetBorderSide;\n    // prevent arrowElement from being placed not contiguously to its target\n    sideValue = Math.max(Math.min(targetOffsets[len] - (arrowElementSize + 5), sideValue), 0);\n    data.offsets.arrow = {\n        [side]: Math.round(sideValue),\n        [altSide]: '' // make sure to unset any eventual altSide value from the DOM node\n    };\n    data.instance.arrow = arrowElement;\n    return data;\n}\n\nfunction flip(data) {\n    data.offsets.target = getClientRect(data.offsets.target);\n    if (!isModifierEnabled(data.options, 'flip')) {\n        data.offsets.target = {\n            ...data.offsets.target,\n            ...getTargetOffsets(data.instance.target, data.offsets.host, data.placement)\n        };\n        return data;\n    }\n    const boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n    'viewport', false // positionFixed\n    );\n    let placement = data.placement.split(' ')[0];\n    let variation = data.placement.split(' ')[1] || '';\n    const offsetsHost = data.offsets.host;\n    const target = data.instance.target;\n    const host = data.instance.host;\n    const adaptivePosition = computeAutoPlacement('auto', offsetsHost, target, host, data.options.allowedPositions);\n    const flipOrder = [placement, adaptivePosition];\n    flipOrder.forEach((step, index) => {\n        if (placement !== step || flipOrder.length === index + 1) {\n            return;\n        }\n        placement = data.placement.split(' ')[0];\n        // using floor because the host offsets may contain decimals we are not going to consider here\n        const overlapsRef = (placement === 'left' &&\n            Math.floor(data.offsets.target.right ?? 0) > Math.floor(data.offsets.host.left ?? 0)) ||\n            (placement === 'right' &&\n                Math.floor(data.offsets.target.left ?? 0) < Math.floor(data.offsets.host.right ?? 0)) ||\n            (placement === 'top' &&\n                Math.floor(data.offsets.target.bottom ?? 0) > Math.floor(data.offsets.host.top ?? 0)) ||\n            (placement === 'bottom' &&\n                Math.floor(data.offsets.target.top ?? 0) < Math.floor(data.offsets.host.bottom ?? 0));\n        const overflowsLeft = Math.floor(data.offsets.target.left ?? 0) < Math.floor(boundaries.left ?? 0);\n        const overflowsRight = Math.floor(data.offsets.target.right ?? 0) > Math.floor(boundaries.right ?? 0);\n        const overflowsTop = Math.floor(data.offsets.target.top ?? 0) < Math.floor(boundaries.top ?? 0);\n        const overflowsBottom = Math.floor(data.offsets.target.bottom ?? 0) > Math.floor(boundaries.bottom ?? 0);\n        const overflowsBoundaries = (placement === 'left' && overflowsLeft) ||\n            (placement === 'right' && overflowsRight) ||\n            (placement === 'top' && overflowsTop) ||\n            (placement === 'bottom' && overflowsBottom);\n        // flip the variation if required\n        const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n        const flippedVariation = ((isVertical && variation === 'left' && overflowsLeft) ||\n            (isVertical && variation === 'right' && overflowsRight) ||\n            (!isVertical && variation === 'left' && overflowsTop) ||\n            (!isVertical && variation === 'right' && overflowsBottom));\n        if (overlapsRef || overflowsBoundaries || flippedVariation) {\n            if (overlapsRef || overflowsBoundaries) {\n                placement = flipOrder[index + 1];\n            }\n            if (flippedVariation) {\n                variation = getOppositeVariation(variation);\n            }\n            data.placement = placement + (variation ? ` ${variation}` : '');\n            data.offsets.target = {\n                ...data.offsets.target,\n                ...getTargetOffsets(data.instance.target, data.offsets.host, data.placement)\n            };\n        }\n    });\n    return data;\n}\n\nfunction initData(targetElement, hostElement, position, options) {\n    if (!targetElement || !hostElement) {\n        return;\n    }\n    const hostElPosition = getReferenceOffsets(targetElement, hostElement);\n    if (!position.match(/^(auto)*\\s*(left|right|top|bottom|start|end)*$/)\n        && !position.match(/^(left|right|top|bottom|start|end)*(?: (left|right|top|bottom|start|end))*$/)) {\n        position = 'auto';\n    }\n    const placementAuto = !!position.match(/auto/g);\n    // support old placements 'auto left|right|top|bottom'\n    let placement = position.match(/auto\\s(left|right|top|bottom|start|end)/)\n        ? position.split(' ')[1] || 'auto'\n        : position;\n    // Normalize placements that have identical main placement and variation (\"right right\" => \"right\").\n    const matches = placement.match(/^(left|right|top|bottom|start|end)* ?(?!\\1)(left|right|top|bottom|start|end)?/);\n    if (matches) {\n        placement = matches[1] + (matches[2] ? ` ${matches[2]}` : '');\n    }\n    // \"left right\", \"top bottom\" etc. placements also considered incorrect.\n    if (['left right', 'right left', 'top bottom', 'bottom top'].indexOf(placement) !== -1) {\n        placement = 'auto';\n    }\n    placement = computeAutoPlacement(placement, hostElPosition, targetElement, hostElement, options ? options.allowedPositions : undefined);\n    const targetOffset = getTargetOffsets(targetElement, hostElPosition, placement);\n    return {\n        options: options || { modifiers: {} },\n        instance: {\n            target: targetElement,\n            host: hostElement,\n            arrow: void 0\n        },\n        offsets: {\n            target: targetOffset,\n            host: hostElPosition,\n            arrow: void 0\n        },\n        positionFixed: false,\n        placement,\n        placementAuto\n    };\n}\n\nfunction preventOverflow(data) {\n    if (!isModifierEnabled(data.options, 'preventOverflow')) {\n        return data;\n    }\n    // NOTE: DOM access here\n    // resets the target Offsets's position so that the document size can be calculated excluding\n    // the size of the targetOffsets element itself\n    const transformProp = 'transform';\n    const targetStyles = data.instance.target.style; // assignment to help minification\n    const { top, left, [transformProp]: transform } = targetStyles;\n    targetStyles.top = '';\n    targetStyles.left = '';\n    targetStyles[transformProp] = '';\n    const boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n    data.options.modifiers.preventOverflow?.boundariesElement || 'scrollParent', false // positionFixed\n    );\n    // NOTE: DOM access here\n    // restores the original style properties after the offsets have been computed\n    targetStyles.top = top;\n    targetStyles.left = left;\n    targetStyles[transformProp] = transform;\n    const order = ['left', 'right', 'top', 'bottom'];\n    const check = {\n        primary(placement) {\n            let value = data.offsets.target[placement];\n            // options.escapeWithReference\n            if ((data.offsets.target[placement] ?? 0) < (boundaries[placement] ?? 0)) {\n                value = Math.max(data.offsets.target[placement] ?? 0, boundaries[placement] ?? 0);\n            }\n            return { [placement]: value };\n        },\n        secondary(placement) {\n            const isPlacementHorizontal = placement === 'right';\n            const mainSide = isPlacementHorizontal ? 'left' : 'top';\n            const measurement = isPlacementHorizontal ? 'width' : 'height';\n            let value = data.offsets.target[mainSide];\n            // escapeWithReference\n            if ((data.offsets.target[placement] ?? 0) > (boundaries[placement] ?? 0)) {\n                value = Math.min(data.offsets.target[mainSide] ?? 0, (boundaries[placement] ?? 0) - data.offsets.target[measurement]);\n            }\n            return { [mainSide]: value };\n        }\n    };\n    order.forEach((placement) => {\n        const side = ['left', 'top', 'start'].indexOf(placement) !== -1 ? check['primary'] : check['secondary'];\n        data.offsets.target = {\n            ...data.offsets.target,\n            ...side(placement)\n        };\n    });\n    return data;\n}\n\nfunction shift(data) {\n    const placement = data.placement;\n    const basePlacement = placement.split(' ')[0];\n    const shiftVariation = placement.split(' ')[1];\n    if (shiftVariation) {\n        const { host, target } = data.offsets;\n        const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n        const side = isVertical ? 'left' : 'top';\n        const measurement = isVertical ? 'width' : 'height';\n        const shiftOffsets = {\n            start: { [side]: host[side] },\n            end: {\n                [side]: (host[side] ?? 0) + host[measurement] - target[measurement]\n            }\n        };\n        data.offsets.target = {\n            ...target, ...{\n                [side]: (side === shiftVariation ? shiftOffsets.start[side] : shiftOffsets.end[side])\n            }\n        };\n    }\n    return data;\n}\n\nclass Positioning {\n    position(hostElement, targetElement /*, round = true*/) {\n        return this.offset(hostElement, targetElement /*, false*/);\n    }\n    offset(hostElement, targetElement /*, round = true*/) {\n        return getReferenceOffsets(targetElement, hostElement);\n    }\n    positionElements(hostElement, targetElement, position, appendToBody, options) {\n        const chainOfModifiers = [flip, shift, preventOverflow, arrow];\n        const _position = MapPlacementInToRL[position];\n        const data = initData(targetElement, hostElement, _position, options);\n        if (!data) {\n            return;\n        }\n        return chainOfModifiers.reduce((modifiedData, modifier) => modifier(modifiedData), data);\n    }\n}\nconst positionService = new Positioning();\nfunction positionElements(hostElement, targetElement, placement, appendToBody, options, renderer) {\n    const data = positionService.positionElements(hostElement, targetElement, placement, appendToBody, options);\n    if (!data) {\n        return;\n    }\n    const offsets = getOffsets(data);\n    setStyles(targetElement, {\n        'will-change': 'transform',\n        top: '0px',\n        left: '0px',\n        transform: `translate3d(${offsets.left}px, ${offsets.top}px, 0px)`\n    }, renderer);\n    if (data.instance.arrow) {\n        setStyles(data.instance.arrow, data.offsets.arrow, renderer);\n    }\n    updateContainerClass(data, renderer);\n}\n\nclass PositioningService {\n    constructor(ngZone, rendererFactory, platformId) {\n        this.update$$ = new Subject();\n        this.positionElements = new Map();\n        this.isDisabled = false;\n        if (isPlatformBrowser(platformId)) {\n            ngZone.runOutsideAngular(() => {\n                this.triggerEvent$ = merge(fromEvent(window, 'scroll', { passive: true }), fromEvent(window, 'resize', { passive: true }), of(0, animationFrameScheduler), this.update$$);\n                this.triggerEvent$.subscribe(() => {\n                    if (this.isDisabled) {\n                        return;\n                    }\n                    this.positionElements\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        .forEach((positionElement) => {\n                        positionElements(_getHtmlElement(positionElement.target), _getHtmlElement(positionElement.element), positionElement.attachment, positionElement.appendToBody, this.options, rendererFactory.createRenderer(null, null));\n                    });\n                });\n            });\n        }\n    }\n    position(options) {\n        this.addPositionElement(options);\n    }\n    get event$() {\n        return this.triggerEvent$;\n    }\n    disable() {\n        this.isDisabled = true;\n    }\n    enable() {\n        this.isDisabled = false;\n    }\n    addPositionElement(options) {\n        this.positionElements.set(_getHtmlElement(options.element), options);\n    }\n    calcPosition() {\n        this.update$$.next(null);\n    }\n    deletePositionElement(elRef) {\n        this.positionElements.delete(_getHtmlElement(elRef));\n    }\n    setOptions(options) {\n        this.options = options;\n    }\n}\nPositioningService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.0.6\", ngImport: i0, type: PositioningService, deps: [{ token: i0.NgZone }, { token: i0.RendererFactory2 }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\nPositioningService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.0.6\", ngImport: i0, type: PositioningService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.0.6\", ngImport: i0, type: PositioningService, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i0.RendererFactory2 }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }]; } });\nfunction _getHtmlElement(element) {\n    // it means that we got a selector\n    if (typeof element === 'string') {\n        return document.querySelector(element);\n    }\n    if (element instanceof ElementRef) {\n        return element.nativeElement;\n    }\n    return element ?? null;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { PlacementForBs5, Positioning, PositioningService, checkMargins, positionElements };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}